---
title: |
  <center> **Supporting materials for:** </center>
  <center> Many purported pseudogenes in bacterial genomes are bonafide genes </center>
author:
  - Nicholas P. Cooley, Department of Biomedical Informatics, University of Pittsburgh
  - Erik S. Wright, Department of Biomedical Informatics, University of Pittsburgh
output:
  pdf_document:
    toc: true
toc-title: "Table of Contents"
---


```{r, libraries and functions, include = TRUE, echo = FALSE}
suppressMessages(library(SynExtend))
suppressMessages(library(ggmsa))
suppressMessages(library(knitr))
suppressMessages(library(kableExtra))
suppressMessages(library(ggplot2))
# suppressMessages(library(grid))
# suppressMessages(library(gridBase))
source(file = "RFunctions/BAMImport.R",
       echo = FALSE)
source(file = "RFunctions/Bowtie2Mapping.R",
       echo = FALSE)
source(file = "RFunctions/SyntenyMapping.R",
       echo = FALSE)
source(file = "RFunctions/Minimap2Mapping.R",
       echo = FALSE)

# Function to plot color bar
color.bar <- function(lut,
                      min1,
                      max1 = -min1,
                      min2,
                      max2 = -min2,
                      mina,
                      maxa,
                      minb,
                      maxb,
                      nticks = 10,
                      ticks1 = seq(min1,
                                   max1,
                                   len = nticks),
                      ticks2 = seq(min2,
                                   max2,
                                   len = nticks),
                      ticksa = seq(mina,
                                   maxa,
                                   len = nticks),
                      ticksb = seq(minb,
                                   maxb,
                                   len = nticks),
                      title='') {
  scale <- (length(lut)-1)/(max1-min1)
  
  # dev.new(width = 1.75,
  #         height = 5)
  plot(c(0,5),
       c(min1,max1),
       type = 'n',
       bty = 'n',
       xaxt = 'n',
       xlab = '',
       yaxt = 'n',
       ylab = '')
  # text(x = 2.5,
  #      y = max1 + 1,
  #      cex = 0.5,
  #      labels = title)
  mtext(text = title,
        side = 3,
        cex = 0.5)
  axis(side = 2,
       at = ticks1,
       labels = paste0(formatC(ticks1, digits = 2),
                       " (",
                       formatC(ticks2, digits = 2),
                       ")"),
       las = 1,
       cex = 0.5)
  axis(side = 4,
       at = ticks1,
       labels = paste0(formatC(ticksa, digits = 2),
                       " (",
                       formatC(ticksb, digits = 2),
                       ")"),
       las = 1,
       cex = 0.5)
  for (i in 1:(length(lut)-1)) {
    y = (i-1)/scale + min1
    rect(0.25,
         y,
         4.75,
         y+1/scale,
         col = lut[i],
         border = NA)
  }
}

ColVec1 <- c('#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#42d4f4', '#f032e6', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#000075', '#a9a9a9', '#ffffff', '#000000')
ColVec2 <- paste0(ColVec1,
                  "33")
ColVec3 <- paste0(ColVec1,
                  "15")

# The plots in this supporting information are generated by an RMarkdown file that has relatively few dependencies and is exposed in this github repository associated with this publication.
# Read mapping can be done with any of the short pipelines provided in that same repository, though in the case of the data generated here all three provide the same results.
# Because of this, only the synteny mapping is performed to make reproduction easier.
# The bowtie2 and minimap2 pipelines rely on their respective tools, as well as the R package RSamtools.

# The plots in this supporting information are generated by an RMarkdown file that has relatively few dependencies and is exposed in this github repository associated with this publication.
# Read mapping can be done with any of the short pipelines provided in that same repository, though in the case of the data generated here all three provide the same results.
# Because of this, only the synteny mapping is performed to make reproduction easier.
# The bowtie2 and minimap2 pipelines rely on their respective tools, as well as the R package RSamtools.

# A pair of *e. coli* isolates whose published assemblies contained more pseuodogenes than seemed reasonable were examined and sanger reads for some of those pseudogenes were generated.
# 26 reads were initially collected, after quality filtering this left 19 reads, split 10 to one genome and 9 to another.
# Strain NR 51487 corresponds to the genbank assembly GCF_001593565.1, while strain NR 32771 corresponds to GCF_000350925.1, read primers and other associated notes are present in accompanying .csv files in the associated github repository.

# GCF_001593565.1 is a refseq assembly, assembled from 118x PacBio reads by HGAP v3
# Refseq is identical to Genbank
# 
```


```{r, paths and things, include = TRUE, echo = FALSE}
PATHS <- c("InputData/Primers and Plate Layouts.xlsx", # never actually called on because it's not entirely parseable, though here in cade someone needs it
           "SangerReads", # folder containing sequencing results, path is github wd
           "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/001/593/565/GCF_001593565.1_ASM159356v1/", # nr 51487 on spreadsheet
           "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/350/925/GCF_000350925.1_Esch_coli_KTE181_V1/") # nr 32771 on spreadsheet
```

```{r, import reads, include = TRUE, echo = FALSE}
CHECKFILES <- list.files(path = "InputData",
                         full.names = FALSE)

if (!("MapResults.RData" %in% CHECKFILES)) {
  
  FILES01 <- list.files(path = PATHS[2L],
                        full.names = TRUE,
                        pattern = ".phd.1")
  
  ref1 <- c("H01",
            "F02",
            "A01",
            "F01",
            "A02",
            "B02",
            "C02",
            "B01",
            "C01",
            "D01",
            "E01",
            "G02",
            "H02",
            "A03",
            "D02",
            "E02",
            "G01")
  
  ref2 <- c("B03",
            "C03",
            "D03",
            "E03",
            "F03",
            "G03",
            "H03",
            "A04",
            "B04")
  
  NS <- unlist(regmatches(x = FILES01,
                          m = gregexpr(pattern = "(?<=SangerReads/)([0-9]+)(?=_PREMIX)",
                                       text = FILES01,
                                       perl = TRUE)))
  NS <- unlist(regmatches(x = FILES01,
                          m = gregexpr(pattern = "(?<=20220215_)([A-Z0-9]+)(?=\\.phd)",
                                       text = FILES01,
                                       perl = TRUE)))
  
  strs <- qual <- vector(mode = "character",
                         length = length(NS))
  
  for (m1 in seq_along(NS)) {
    r <- readLines(FILES01[m1])
    r <- r[(which(r=="BEGIN_DNA")[1] + 1):(which(r=="END_DNA")[1] - 1)]
    r <- strsplit(x = r,
                  split = " ",
                  fixed = TRUE)
    # strs[m1] <- paste(sapply(r, `[`, 1L), collapse="")
    strs[m1] <- paste(sapply(X = r,
                             FUN = `[`,
                             1L),
                      collapse = "")
    qual[m1] <- paste(rawToChar(as.raw(as.numeric(sapply(r, `[`, 2L)) + 33)), collapse="")
  }
  
  strs <- DNAStringSet(strs)
  names(strs) <- NS
  qual2 <- PhredQuality(qual)
  
  # head(strs)
  
  x <- QualityScaledDNAStringSet(x = strs,
                                 quality = qual2)
  
  Seqs <- TrimDNA(myDNAStringSet = x,
                  leftPatterns = "",
                  rightPatterns = "",
                  type = "sequence",
                  quality = x@quality)
  
  
  ASSEMBLY1 <- strsplit(x = PATHS[3],
                        split = "/",
                        fixed = TRUE)
  GENECALLS1 <- paste0(PATHS[3],
                       ASSEMBLY1[[1]][10],
                       "_genomic.gff.gz")
  ASSEMBLY1 <- paste0(PATHS[3],
                      ASSEMBLY1[[1]][10],
                      "_genomic.fna.gz")
  ASSEMBLY2 <- strsplit(x = PATHS[4],
                        split = "/",
                        fixed = TRUE)
  GENECALLS2 <- paste0(PATHS[4],
                       ASSEMBLY2[[1]][10],
                       "_genomic.gff.gz")
  ASSEMBLY2 <- paste0(PATHS[4],
                      ASSEMBLY2[[1]][10],
                      "_genomic.fna.gz")
  
  ASSEMBLY1 <- readDNAStringSet(filepath = ASSEMBLY1)
  ASSEMBLY2 <- readDNAStringSet(filepath = ASSEMBLY2)
  GENECALLS1 <- gffToDataFrame(GFF = GENECALLS1,
                               Verbose = FALSE)
  GENECALLS2 <- gffToDataFrame(GFF = GENECALLS2,
                               Verbose = FALSE)
} else {
  load(file = "InputData/MapResults.RData",
       verbose = FALSE)
}
```

```{r, map reads, include = TRUE, echo = FALSE}

if (!("MapResults.RData" %in% CHECKFILES)) {
  res1 <- SynMappingPipeline(Reads = Seqs[names(Seqs) %in% ref1],
                             Reference = ASSEMBLY1,
                             GeneCalls = GENECALLS1)
  res2 <- SynMappingPipeline(Reads = Seqs[names(Seqs) %in% ref2],
                             Reference = ASSEMBLY2,
                             GeneCalls = GENECALLS2)
  
  save(res1,
       res2,
       Seqs,
       x,
       ref1,
       ref2,
       GENECALLS1,
       GENECALLS2,
       file = "InputData/MapResults.RData",
       compress = "xz")
}

```

\newpage

```{r, plot mappings 1, include = TRUE, echo = FALSE}

featuretypes <- featurenames <- vector(mode = "character",
                                       length = length(res1[[2L]]))

layout(mat = matrix(data = 1:6,
                    ncol = 1))
# par(mar = c(3,1,3,1))
# print out 
for (m1 in seq_along(res1[[2L]])) {
  x1 <- AlignSeqs(myXStringSet = res1[[2L]][[m1]],
                  verbose = FALSE)
  x2 <- gregexpr(pattern = "[^ATCG]",
                 text = x1)
  # if the concensus is entirely expected nucleotides, the read maps perfectly
  # skip plotting
  if (x2[[1]][1] == -1) {
    next
  }
  names(x1)[2] <- "Sanger Read"
  w1 <- min(x2[[1]][1])
  w2 <- max(x2[[1]][1])
  
  if (GENECALLS1$Type[which(GENECALLS1$ID == names(x1)[1])] == "pseudogene") {
    # cat("\nPseudogene\n")
    featuretypes[m1] <- "Pseudogene"
    featurenames[m1] <- names(x1)[1]
  } else {
    # cat("\nRegular gene\n")
    featuretypes[m1] <- "Gene"
    featurenames[m1] <- names(x1)[1]
  }
  
  par(mar = c(3, 1, 1, 1))
  # plot.new()              ## suggested by @Josh
  # vps <- baseViewports()
  # pushViewport(vps$figure) ##   I am in the space of the autocorrelation plot
  # vp1 <-plotViewport(c(2.5,1,0,1)) ## create new vp with margins, you play with this values 
  # par(mgp = c(1.25, .5, 0))
  # p <- ggmsa(x1,
  #            start = w1 - 22,
  #            end = w2 + 16,
  #            color = "Chemistry_NT",
  #            seq_name = TRUE)
  plot(ggmsa(x1,
             start = w1 - 22,
             end = w2 + 16,
             color = "Chemistry_NT",
             seq_name = TRUE) +
         theme(axis.text.x = element_blank()))
  # print(p, vp = vp1)
}

# the six implied errors
# ID=gene-AX202_RS04595 ... Note=frameshifted
# ID=gene-AX202_RS29725 ... Note=frameshifted
# ID=gene-AX202_RS14450 ... Note=frameshifted
# ID=gene-AX202_RS01470 ... Note=frameshifted
# ID=gene-AX202_RS00205 ... Note=frameshifted
# ID=gene-AX202_RS23440 ... Note=frameshifted

```

# Figure S1: Mapping disagreements for *E. coli* strain NR 51487
Alignments of Sanger reads implying assembly errors in the deposited assembly for *E. coli* strain NR 51487 (RefSeq accession: GCF_001593565.1). Of ten successfully generated reads mapping to the deposited RefSeq genome, six imply incorrect frameshifts in a gene annotated as a pseudogene.

\newpage

```{r, distributions by submitter choices, include = TRUE, echo = FALSE}
load(file = "InputData/Technology_Observations_v01.RData",
     verbose = FALSE)

dat1 <- dat1[dat1$Assembler != "Unknown_Other_Uncaptured", ]

ColVec4 <- paste0(ColVec1,
                  "75")
TOPTAX <- head(names(sort(table(dat1$TaxID), decreasing = TRUE)))
dat2 <- dat1[dat1$TaxID %in% as.integer(TOPTAX), ]
pvals1 <- pvals2 <- submitterchoices <- setsizes <- vector(mode = "list",
                                                           length = length(TOPTAX))
TAXNAMES <- c("E. coli",
              "S. pneumoniae",
              "S. aureus",
              "K. pneumoniae")
TAXNAMES <- c("E. coli",
              "L. monocytogenes",
              "K. pneumoniae",
              "S. aureus")

layout(mat = matrix(data = 1:4,
                    ncol = 2))

for (m2 in 1:4) {
  
  pvals1[[m2]] <- pvals2[[m2]] <- vector(mode = "list",
                                         length = 5L)
  
  dat3 <- by(data = dat2[dat2$TaxID %in% as.integer(TOPTAX)[m2], ],
             INDICES = ~ Technology + Assembler,
             FUN = function(x) {
               x$FS_per_MB
             })
  dat4 <- by(data = dat2[dat2$TaxID %in% as.integer(TOPTAX)[m2], ],
             INDICES = ~ Technology + Assembler,
             FUN = function(x) {
               x$IS_per_MB
             })
  w1 <- lengths(dat3)
  w2 <- which(w1 >= sort(w1, decreasing = TRUE)[6], arr.ind = TRUE)
  o1 <- order(w1, decreasing = TRUE)
  head(sort(w1, decreasing = TRUE), n = 15)
  
  # find the most populated distribution
  # ask how different all of the smaller top six are from the largest
  w3 <- w4 <- quants1 <- quants2 <- vector(mode = "list",
                                           length = 6L)
  combonames <- vector(mode = "character",
                       length = 6L)
  combosizes <- vector(mode = "integer",
                       length = 6L)
  
  for (m1 in seq_len(nrow(w2))) {
    w3[[m1]] <- dat3[[w2[m1, 1], w2[m1, 2]]]
    w4[[m1]] <- dat4[[w2[m1, 1], w2[m1, 2]]]
    combonames[m1] <- paste(dimnames(dat3)[[1]][w2[m1, 1]],
                            dimnames(dat3)[[2]][w2[m1, 2]],
                            sep = " + ")
    combosizes[m1] <- length(w3[[m1]])
    quants1[[m1]] <- quantile(x = w3[[m1]],
                              probs = c(0.01, 0.99))
    quants2[[m1]] <- quantile(x = w4[[m1]],
                              probs = c(0.01, 0.99))
  }
  
  o2 <- order(combosizes, decreasing = TRUE)
  w3 <- w3[o2]
  w4 <- w4[o2]
  combonames <- combonames[o2]
  combosizes <- combosizes[o2]
  submitterchoices[[m2]] <- combonames
  setsizes[[m2]] <- combosizes
  if (m2 == 1L) {
    par(mar = c(3,4,2,1.5),
        mgp = c(1.75, 1, 0))
  } else if (m2 == 2L) {
    par(mar = c(3,4,2,1.5),
        mgp = c(1.75, 1, 0))
  } else if (m2 == 3L) {
    par(mar = c(3,3.5,2,2),
        mgp = c(1.75, 1, 0))
  } else {
    par(mar = c(3,3.5,2,2),
        mgp = c(1.75, 1, 0))
  }
  plot(x = 0,
       y = 0,
       type = "n",
       # xlim = c(min(mean(sapply(X = quants1,
       #                          FUN = function(x) {
       #                            x[1]
       #                          })),
       #              mean(sapply(X = quants2,
       #                          FUN = function(x) {
       #                            x[1]
       #                          }))),
       #          max(mean(sapply(X = quants1,
       #                          FUN = function(x) {
       #                            x[2]
       #                          })),
       #              mean(sapply(X = quants2,
       #                          FUN = function(x) {
       #                            x[2]
       #                          })))),
       xlim = c(min(c(sapply(X = quants1,
                             FUN = function(x) {
                               x[1]
                             }),
                      sapply(X = quants2,
                             FUN = function(x) {
                               x[1]
                             }))),
                max(mean(sapply(X = quants1,
                                FUN = function(x) {
                                  x[2]
                                })),
                    mean(sapply(X = quants2,
                                FUN = function(x) {
                                  x[2]
                                })))),
       ylim = c(0, 1),
       xaxs = "i",
       yaxs = "i",
       xlab = if (m2 %% 2 == 0) {
         "Pseudogenes per Mbp"
       } else {
         ""
       },
       ylab = if (m2 < 3) {
         "Cumulative Frequency"
       } else {
         ""
       },
       main = bquote(italic(.(TAXNAMES[m2]))))
  
  for (m1 in seq_len(6L)) {
    
    lines(x = sort(w3[[m1]]),
          y = seq(length(w3[[m1]])) / length(w3[[m1]]),
          lty = 1,
          lwd = if (m1 == 1L) {
            3
          } else {
            1
          },
          col = if (m1 == 1) {
            ColVec1[m1]
          } else {
            ColVec4[m1]
          })
    
    if (m1 > 1) {
      pvals1[[m2]][[m1 - 1L]] <- suppressWarnings(ks.test(x = w3[[1L]],
                                                          y = w3[[m1]]))
    }
    
    lines(x = sort(w4[[m1]]),
          y = seq(length(w4[[m1]])) / length(w4[[m1]]),
          lty = 3,
          lwd = if (m1 == 1L) {
            3
          } else {
            1
          },
          col = if (m1 == 1) {
            ColVec1[m1]
          } else {
            ColVec4[m1]
          })
    if (m1 > 1) {
      pvals2[[m2]][[m1 - 1L]] <- suppressWarnings(ks.test(x = w4[[1L]],
                                                          y = w4[[m1]]))
    }
  }
  if (m2 == 1L) {
    legend("bottomright",
           cex = 0.75,
           legend = c("1st",
                      "2nd",
                      "3rd",
                      "4th",
                      "5th",
                      "6th"),
           lty = 1,
           lwd = c(3,1,1,1,1,1),
           col = ColVec1[1:6],
           bty = "n",
           bg = NA)
  }
}

newtabs <- vector(mode = "list",
                  length = length(TOPTAX))
for (m1 in seq_along(newtabs)) {
  newtabs[[m1]] <- data.frame("FS_P-values" = sapply(X = pvals1[[m1]][1:5],
                                                     FUN = function(x) {
                                                       x$p.value
                                                     }),
                              "FS_D_statistic" = sapply(X = pvals1[[m1]][1:5],
                                                        FUN = function(x) {
                                                          x$statistic
                                                        }),
                              "IS_P-values" = sapply(X = pvals2[[m1]][1:5],
                                                     FUN = function(x) {
                                                       x$p.value
                                                     }),
                              "IS_D_statistic" = sapply(X = pvals2[[m1]][1:5],
                                                        FUN = function(x) {
                                                          x$statistic
                                                        }),
                              "Count" = setsizes[[m1]][2:6],
                              row.names = submitterchoices[[m1]][2:6])
}

```

# Figure S2: Pseudogene distributions within species
The top four most common species with captured assembler metadata were split into the top six most common combinations of submitter choices for reported assembler and technology represented by available SRA reads. The most common choice category in every species was a combination of SPAdes and a single SRA run of Illumina reads, and is represented in bold in each plot. Internal stops are represented by dotted lines, and frameshifts are represented by solid lines. The top four species present in this data, in order are *E. coli* (top left), *L. monocytogenes* (bottom left), *K. pneumoniae* (top right), and *P. aeruginosa* (bottom right). Descriptions of comparisons of the minor submitter choice combinations with the major submitter choice combination are present in **Table S1**. Inset legend names refer the rows in the associated supplemental table.

\newpage

```{r, model coefficients, include = TRUE, echo = FALSE}
load(file = "InputData/SimulatedEcoliStats.RData",
     verbose = FALSE)

# (abs(abs_fs - found_ref_fs) / total_genes)

###### -- color ramp 1 --------------------------------------------------------

# deprecated, not really appropriate 

# ramp green-ish to white to blue-ish, from min to zero and out to abs of the min (which is always zero in this case)
ColVectorRamp <- colorRampPalette(colors = c(ColVec1[2L], "white", ColVec1[4L]))(101)
# bin out the results for cov and qual for frameshifts
FS_BINS_A <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = -min(floor(range(fs_vals03[, 2:3]))),
                                                  length.out = 101)),
                    nrow = nrow(fs_vals03))
# bin out the results for intercepts for frameshifts
FS_BINS_B <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 1]))),
                                                  to = -min(floor(range(fs_vals03[, 1]))),
                                                  length.out = 101)),
                    nrow = nrow(fs_vals03))
# bin out the results for cov and qual for internal stops
IS_BINS_A <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = -min(floor(range(is_vals03[, 2:3]))),
                                                  length.out = 101)),
                    nrow = nrow(is_vals03))
# bin out the results for intercepts for internal stops
IS_BINS_B <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 1]))),
                                                  to = -min(floor(range(is_vals03[, 1]))),
                                                  length.out = 101)),
                    nrow = nrow(is_vals03))

###### -- color ramp 2 --------------------------------------------------------

# ramp green-ish to white , staying within the color palette of the rest of the paper from min to zero
ColVectorRamp <- colorRampPalette(colors = c(ColVec1[2L], "white"))(100)
# bin out the results for intercept for frameshifts
FS_BINS_A <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 1]))),
                                                  to = max(ceiling(range(fs_vals03[, 1]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for coverage for frameshifts
FS_BINS_B <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = max(ceiling(range(fs_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for quality for frameshifts
FS_BINS_C <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = max(ceiling(range(fs_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for intercept for internal stops
IS_BINS_A <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 1]))),
                                                  to = max(ceiling(range(is_vals03[, 1]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))
# bin out the results for coverage for internal stops
IS_BINS_B <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = max(ceiling(range(is_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))
# bin out the results for quality for internal stops
IS_BINS_C <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = max(ceiling(range(is_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))


o1 <- c(1:4, 13, 16) # paired end
o2 <- c(5:8, 14, 17)
o3 <- c(9:12, 15, 18)
o4 <- c(19:22, 31, 34) # single end
o5 <- c(23:26, 32, 35)
o6 <- c(27:30, 33, 36)
fs_vals05 <- cbind(fs_vals03[o1, ],
                   fs_vals03[o2, ],
                   fs_vals03[o3, ])
fs_vals05 <- fs_vals05[, c(1,4,7,2,5,8,3,6,9)]
fs_vals06 <- cbind(fs_vals03[o4, ],
                   fs_vals03[o5, ],
                   fs_vals03[o6, ])
fs_vals06 <- fs_vals06[, c(1,4,7,2,5,8,3,6,9)]
fs_vals07 <- cbind(fs_vals04[o1, ],
                   fs_vals04[o2, ],
                   fs_vals04[o3, ])
fs_vals07 <- fs_vals07[, c(1,4,7,2,5,8,3,6,9)]
fs_vals08 <- cbind(fs_vals04[o4, ],
                   fs_vals04[o5, ],
                   fs_vals04[o6, ])
fs_vals08 <- fs_vals08[, c(1,4,7,2,5,8,3,6,9)]

is_vals05 <- cbind(is_vals03[o1, ],
                   is_vals03[o2, ],
                   is_vals03[o3, ])
is_vals05 <- is_vals05[, c(1,4,7,2,5,8,3,6,9)]
is_vals06 <- cbind(is_vals03[o4, ],
                   is_vals03[o5, ],
                   is_vals03[o6, ])
is_vals06 <- is_vals06[, c(1,4,7,2,5,8,3,6,9)]
is_vals07 <- cbind(is_vals04[o1, ],
                   is_vals04[o2, ],
                   is_vals04[o3, ])
is_vals07 <- is_vals07[, c(1,4,7,2,5,8,3,6,9)]
is_vals08 <- cbind(is_vals04[o4, ],
                   is_vals04[o5, ],
                   is_vals04[o6, ])
is_vals08 <- is_vals08[, c(1,4,7,2,5,8,3,6,9)]

BINS01 <- cbind(FS_BINS_A[o1, ],
                FS_BINS_B[o2, ],
                FS_BINS_C[o3, ])
BINS01 <- BINS01[, c(1,4,7,2,5,8,3,6,9)]
BINS02 <- cbind(FS_BINS_A[o4, ],
                FS_BINS_B[o5, ],
                FS_BINS_C[o6, ])
BINS02 <- BINS02[, c(1,4,7,2,5,8,3,6,9)]

BINS03 <- cbind(IS_BINS_A[o1, ],
                IS_BINS_B[o2, ],
                IS_BINS_C[o3, ])
BINS03 <- BINS03[, c(1,4,7,2,5,8,3,6,9)]
BINS04 <- cbind(IS_BINS_A[o4, ],
                IS_BINS_B[o5, ],
                IS_BINS_C[o6, ])
BINS04 <- BINS04[, c(1,4,7,2,5,8,3,6,9)]

layout(mat = matrix(data = c(1,1,1,1,3,2,2,2,2,
                             1,1,1,1,3,2,2,2,2,
                             1,1,1,1,3,2,2,2,2,
                             1,1,1,1,3,2,2,2,2),
                    ncol = 9,
                    byrow = TRUE))

par(mar = c(4, 6, 6, 1),
    mgp = c(1.5, 1, 0))
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(0, ncol(fs_vals05)),
     ylim = c(0, nrow(fs_vals05)),
     xaxs = "i",
     yaxs = "i",
     axes = FALSE,
     frame.plot = TRUE,
     ylab = "",
     xlab = "Frameshifts")
z1 <- rev(seq(nrow(fs_vals05)))
for (m1 in seq_len(nrow(fs_vals05))) {
  for (m2 in seq_len(ncol(fs_vals05))) {
    # rect(xleft = m2,
    #      xright = m2 - 1L,
    #      ytop = z1[m1],
    #      ybottom = z1[m1] - 1L,
    #      col = ColVectorRamp[BINS02[m1, m2]],
    #      border = NA)
    polygon(x = c(m2, m2 - 1L, m2 - 1L),
            y = c(z1[m1], z1[m1], z1[m1] - 1L),
            border = NULL,
            col = ColVectorRamp[BINS01[m1, m2]],
            lwd = 0.15)
    if (fs_vals07[m1, m2] < 0.01) {
      text(x = m2 - 0.75,
           y = z1[m1] - 0.25,
           labels = "*")
    }
    polygon(x = c(m2 - 1L, m2, m2),
            y = c(z1[m1] - 1L, z1[m1] - 1L, z1[m1]),
            border = NULL,
            col = ColVectorRamp[BINS02[m1, m2]],
            lwd = 0.15)
    if (fs_vals08[m1, m2] < 0.01) {
      text(x = m2 - 0.25,
           y = z1[m1] - 0.75,
           labels = "*")
    }
  }
}

text(x = rep(0, nrow(fs_vals05)),
     y = z1 - 0.5,
     labels = c("MEGAHIT",
                "SKESA",
                "SPAdes",
                "Unicycler",
                "Unicycler + ONT",
                "Unicycler + PB"),
     xpd = TRUE,
     pos = 2L,
     cex = 0.75)
text(x = seq_len(ncol(fs_vals05)) - 1L,
     y = rep(nrow(fs_vals05), ncol(fs_vals05)) + 0.25,
     pos = 4,
     xpd = TRUE,
     cex = 0.75,
     labels = rep(c("HiSeq 2500",
                    "HiSeq X",
                    "MiSeq v3"),
                  3L),
     srt = 45,
     adj = 0)
text(x = c(2, 5, 8),
     y = rep(nrow(fs_vals05), ncol(fs_vals05)) + 1,
     xpd = TRUE,
     cex = 0.75,
     labels = c("Intercept",
                "Coverage",
                "Quality"))
rect(xleft = c(0, 3, 6),
     xright = c(6, 9, 12),
     ytop = 6,
     ybottom = 0,
     col = NULL,
     lwd = 1)
# bottom left
par(mar = c(4, 3, 6, 4),
    mgp = c(1.5, 1, 0))
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(0, ncol(is_vals05)),
     ylim = c(0, nrow(is_vals05)),
     xaxs = "i",
     yaxs = "i",
     axes = FALSE,
     frame.plot = TRUE,
     ylab = "",
     xlab = "Internal Stops")
z1 <- rev(seq(nrow(is_vals05)))
for (m1 in seq_len(nrow(is_vals05))) {
  for (m2 in seq_len(ncol(is_vals05))) {
    # rect(xleft = m2,
    #      xright = m2 - 1L,
    #      ytop = z1[m1],
    #      ybottom = z1[m1] - 1L,
    #      col = ColVectorRamp[BINS02[m1, m2]],
    #      border = NA)
    polygon(x = c(m2, m2 - 1L, m2 - 1L),
            y = c(z1[m1], z1[m1], z1[m1] - 1L),
            border = NULL,
            col = ColVectorRamp[BINS03[m1, m2]],
            lwd = 0.15)
    if (is_vals07[m1, m2] < 0.01) {
      text(x = m2 - 0.75,
           y = z1[m1] - 0.25,
           labels = "*")
    }
    polygon(x = c(m2 - 1L, m2, m2),
            y = c(z1[m1] - 1L, z1[m1] - 1L, z1[m1]),
            border = NULL,
            col = ColVectorRamp[BINS04[m1, m2]],
            lwd = 0.15)
    if (is_vals08[m1, m2] < 0.01) {
      text(x = m2 - 0.25,
           y = z1[m1] - 0.75,
           labels = "*")
    }
  }
}
text(x = seq_len(ncol(fs_vals05)) - 1L,
     y = rep(nrow(fs_vals05), ncol(fs_vals05)) + 0.25,
     pos = 4,
     xpd = TRUE,
     cex = 0.75,
     labels = rep(c("HiSeq 2500",
                    "HiSeq X",
                    "MiSeq v3"),
                  3L),
     srt = 45,
     adj = 0)
text(x = c(2, 5, 8),
     y = rep(nrow(fs_vals05), ncol(fs_vals05)) + 1,
     xpd = TRUE,
     cex = 0.75,
     labels = c("Intercept",
                "Coverage",
                "Quality"))
rect(xleft = c(0, 3, 6),
     xright = c(6, 9, 12),
     ytop = 6,
     ybottom = 0,
     col = NULL,
     lwd = 1)
# text(x = 4.5,
#      y = nrow(fs_vals05) + 2.1,
#      xpd = TRUE,
#      cex = 0.75,
#      labels = "Internal stops")

# frameshift colorbar
par(mar = c(5,4,9,2),
    cex = 0.5)
color.bar(lut = ColVectorRamp,
          min1 = min(fs_vals03[, 1]),
          max1 = max(fs_vals03[, 1]),
          min2 = min(fs_vals03[, 2:3]),
          max2 = max(fs_vals03[, 2:3]),
          mina = min(is_vals03[, 1]),
          maxa = max(is_vals03[, 1]),
          minb = min(is_vals03[, 2:3]),
          maxb = max(is_vals03[, 2:3]),
          title = "Intercept (Coverage/Quality)",
          nticks = 4)

```

# Figure S3: Fitted model coefficients for assemblies from simulated *E. coli* reads
Coefficients for modeled intercept, coverage, and quality for combinations of simulated Illumina sequencing model and assembler. Each cell is divided diagonally with the upper diagonal representing paired end reads, and the lower diagonal representing single end reads. Coefficients with a Bonferonni corrected p-value < 0.01 are appended with an asterisk (\*) in the cell bisect. The logistic regression coefficients give the change in log odds of the number of pseudogenes per assembly given a unit increase in the fold coverage or Q-score.

\newpage

```{r, fitted-model-behavior-for-quality-scores, include = TRUE, echo = FALSE}
#| fig.width = 3.5, fig.height = 7, fig.align = "center"
load(file = "InputData/SimulatedEcoliStats.RData",
     verbose = FALSE)

tot_genes <- 4379
tot_nts <- 4641652
cov_set <- seq(-1, 1, 0.01)
qual_set <- seq(-4, 6, 0.01)

# given coefficients, predict |delta pseudogenes| per Mbp
predictResponse <- function(coef,
                            COV,
                            QUAL,
                            TOT_GENE,
                            TOT_NT) {
  Y <- coef[1] + coef[2]*COV + coef[3]*QUAL
  Y <- exp(Y)
  Y <- Y/(1 + Y) # |delta pseudogenes| / (total genes)
  Y*TOT_GENE/TOT_NT*1e6 # |delta pseudogenes| / Mbp
}
convertCoverage <- function(cov) {
  50*(10^cov) ### NEED TO VERIFY ### VERIFIED
}
convertQuality <- function(qual) {
  qual + 34 ### NEED TO VERIFY ### still need to verify -- build a quick plot for this ... ### VERIFIED
}

# (abs(abs_fs - found_ref_fs) / total_genes)

###### -- color ramp 1 --------------------------------------------------------

# deprecated, not really appropriate 

# ramp green-ish to white to blue-ish, from min to zero and out to abs of the min (which is always zero in this case)
ColVectorRamp <- colorRampPalette(colors = c(ColVec1[2L], "white", ColVec1[4L]))(101)
# bin out the results for cov and qual for frameshifts
FS_BINS_A <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = -min(floor(range(fs_vals03[, 2:3]))),
                                                  length.out = 101)),
                    nrow = nrow(fs_vals03))
# bin out the results for intercepts for frameshifts
FS_BINS_B <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 1]))),
                                                  to = -min(floor(range(fs_vals03[, 1]))),
                                                  length.out = 101)),
                    nrow = nrow(fs_vals03))
# bin out the results for cov and qual for internal stops
IS_BINS_A <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = -min(floor(range(is_vals03[, 2:3]))),
                                                  length.out = 101)),
                    nrow = nrow(is_vals03))
# bin out the results for intercepts for internal stops
IS_BINS_B <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 1]))),
                                                  to = -min(floor(range(is_vals03[, 1]))),
                                                  length.out = 101)),
                    nrow = nrow(is_vals03))

###### -- color ramp 2 --------------------------------------------------------

# ramp green-ish to white , staying within the color palette of the rest of the paper from min to zero
ColVectorRamp <- colorRampPalette(colors = c(ColVec1[2L], "white"))(100)
# bin out the results for intercept for frameshifts
FS_BINS_A <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 1]))),
                                                  to = max(ceiling(range(fs_vals03[, 1]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for coverage for frameshifts
FS_BINS_B <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = max(ceiling(range(fs_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for quality for frameshifts
FS_BINS_C <- matrix(data = findInterval(x = fs_vals03,
                                        vec = seq(from = min(floor(range(fs_vals03[, 2:3]))),
                                                  to = max(ceiling(range(fs_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(fs_vals03))
# bin out the results for intercept for internal stops
IS_BINS_A <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 1]))),
                                                  to = max(ceiling(range(is_vals03[, 1]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))
# bin out the results for coverage for internal stops
IS_BINS_B <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = max(ceiling(range(is_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))
# bin out the results for quality for internal stops
IS_BINS_C <- matrix(data = findInterval(x = is_vals03,
                                        vec = seq(from = min(floor(range(is_vals03[, 2:3]))),
                                                  to = max(ceiling(range(is_vals03[, 2:3]))),
                                                  length.out = 100)),
                    nrow = nrow(is_vals03))


o1 <- c(1:4, 13, 16) # paired end
o2 <- c(5:8, 14, 17)
o3 <- c(9:12, 15, 18)
o4 <- c(19:22, 31, 34) # single end
o5 <- c(23:26, 32, 35)
o6 <- c(27:30, 33, 36)
fs_vals05 <- cbind(fs_vals03[o1, ],
                   fs_vals03[o2, ],
                   fs_vals03[o3, ])
fs_vals05 <- fs_vals05[, c(1,4,7,2,5,8,3,6,9)]
fs_vals06 <- cbind(fs_vals03[o4, ],
                   fs_vals03[o5, ],
                   fs_vals03[o6, ])
fs_vals06 <- fs_vals06[, c(1,4,7,2,5,8,3,6,9)]
fs_vals07 <- cbind(fs_vals04[o1, ],
                   fs_vals04[o2, ],
                   fs_vals04[o3, ])
fs_vals07 <- fs_vals07[, c(1,4,7,2,5,8,3,6,9)]
fs_vals08 <- cbind(fs_vals04[o4, ],
                   fs_vals04[o5, ],
                   fs_vals04[o6, ])
fs_vals08 <- fs_vals08[, c(1,4,7,2,5,8,3,6,9)]

is_vals05 <- cbind(is_vals03[o1, ],
                   is_vals03[o2, ],
                   is_vals03[o3, ])
is_vals05 <- is_vals05[, c(1,4,7,2,5,8,3,6,9)]
is_vals06 <- cbind(is_vals03[o4, ],
                   is_vals03[o5, ],
                   is_vals03[o6, ])
is_vals06 <- is_vals06[, c(1,4,7,2,5,8,3,6,9)]
is_vals07 <- cbind(is_vals04[o1, ],
                   is_vals04[o2, ],
                   is_vals04[o3, ])
is_vals07 <- is_vals07[, c(1,4,7,2,5,8,3,6,9)]
is_vals08 <- cbind(is_vals04[o4, ],
                   is_vals04[o5, ],
                   is_vals04[o6, ])
is_vals08 <- is_vals08[, c(1,4,7,2,5,8,3,6,9)]

BINS01 <- cbind(FS_BINS_A[o1, ],
                FS_BINS_B[o2, ],
                FS_BINS_C[o3, ])
BINS01 <- BINS01[, c(1,4,7,2,5,8,3,6,9)]
BINS02 <- cbind(FS_BINS_A[o4, ],
                FS_BINS_B[o5, ],
                FS_BINS_C[o6, ])
BINS02 <- BINS02[, c(1,4,7,2,5,8,3,6,9)]

BINS03 <- cbind(IS_BINS_A[o1, ],
                IS_BINS_B[o2, ],
                IS_BINS_C[o3, ])
BINS03 <- BINS03[, c(1,4,7,2,5,8,3,6,9)]
BINS04 <- cbind(IS_BINS_A[o4, ],
                IS_BINS_B[o5, ],
                IS_BINS_C[o6, ])
BINS04 <- BINS04[, c(1,4,7,2,5,8,3,6,9)]

layout(mat = matrix(data = c(1,
                             2),
                    ncol = 1,
                    byrow = TRUE))

par(mar = c(2,3,2,1),
    mgp = c(1.75, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1,
    bg = "white")
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(30, 40),
     ylim = c(0, 5),
     xaxs = "i",
     # xaxt = "n",
     xlab = "",
     ylab = expression("|"*Delta*" Frameshifts per Mbp|"))
axis(side = 1,
     at = seq(from = 30,
              to = 40,
              by = 2),
     labels = NA)
for (m1 in seq_len(nrow(fs_vals05))) {
  for (m2 in seq_len(ncol(fs_vals05) / 3L)) {
    c1 <- predictResponse(coef = fs_vals05[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = 0,
                          QUAL = qual_set,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertQuality(qual = qual_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}
L <- legend(x = 32,
            y = 4,
            legend = rep(NA, 18),
            col = rep(ColVec1[seq_len(6)],
                      3L),
            lty = c(rep(1, 6),
                    rep(2, 6),
                    rep(3, 6)),
            pch = rep(NA, 18),
            ncol = 3L,
            bty = 'n',
            x.intersp = 0.5,
            inset = 0.02,
            cex = 0.75)
legend(x = 32,
       y = 4,
       legend = c("MEGAHIT",
                  "SKESA",
                  "SPAdes",
                  "Unicycler",
                  "Unicycler + ONT",
                  "Unicycler + PB"),
       # col = rep(NA, 6),
       # lty = rep(NA, 6),
       ncol = 1,
       x.intersp = 7.5,
       bg = NA,
       bty = "n",
       cex = 0.75)
text(x = c(32, 33, 34),
     y = 4.025,
     pos = 4,
     xpd = TRUE,
     cex = 0.75,
     labels = rep(c("HiSeq 2500",
                    "HiSeq X",
                    "MiSeq v3"),
                  3L),
     srt = 45,
     adj = 0)
# bottom left paired end internal stops as coverage varies
par(mar = c(3,3,1,1),
    mgp = c(1.75, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1,
    bg = "white")
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(30, 40),
     ylim = c(0, 5),
     xaxs = "i",
     xlab = "Average Q-score",
     ylab = expression("|"*Delta*" Internal stops per Mbp|"))
for (m1 in seq_len(nrow(is_vals05))) {
  for (m2 in seq_len(ncol(is_vals05) / 3L)) {
    c1 <- predictResponse(coef = is_vals05[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = 0,
                          QUAL = qual_set,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertQuality(qual = qual_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}
```

# Figure S4: Modeled behavior of assemblies from simulated reads by average quality score
Predicted models for the absolute difference in frameshifts (top) and internal stops (bottom) per Mbp from a source genome for assemblies generated from simulated reads as average quality scores vary for an array of sequencing platforms and assemblers. Results present are at a fixed coverage of 50-fold.

\newpage

```{r, single-end-model-behavior, include = TRUE, echo = FALSE}
# frameshifts
layout(mat = matrix(data = 1:4,
                    ncol = 2L))
# single end frameshifts for fold coverage
par(mar = c(1, 3, 3.5, 0),
    mgp = c(2, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1)
suppressWarnings(plot(x = 0,
                      y = 0,
                      type = "n",
                      xlim = c(5, 500),
                      ylim = c(0, 5),
                      xaxs = "i",
                      # yaxs = "i",
                      xlab = "",
                      ylab = expression("|"*Delta*" Frameshifts per Mbp|"),
                      log = "x"))
for (m1 in seq_len(nrow(fs_vals06))) {
  for (m2 in seq_len(ncol(fs_vals06) / 3L)) {
    c1 <- predictResponse(coef = fs_vals06[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = cov_set,
                          QUAL = 0,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertCoverage(cov = cov_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}
# single end internal stops for fold coverage
par(mar = c(3, 3, 1.5, 0),
    mgp = c(2, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1)
suppressWarnings(plot(x = 0,
                      y = 0,
                      type = "n",
                      xlim = c(5, 500),
                      ylim = c(0, 5),
                      xaxs = "i",
                      # yaxs = "i",
                      xlab = "Fold Coverage",
                      ylab = expression("|"*Delta*" Internal stops per Mbp|"),
                      log = "x"))
for (m1 in seq_len(nrow(is_vals06))) {
  for (m2 in seq_len(ncol(is_vals06) / 3L)) {
    c1 <- predictResponse(coef = is_vals06[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = cov_set,
                          QUAL = 0,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertCoverage(cov = cov_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}

# single end frameshifts for average q-score
par(mar = c(1, 2, 3.5, 1),
    mgp = c(2, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1)
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(30, 40),
     ylim = c(0, 5),
     xlab = "Average Q-score",
     yaxt = "n",
     # ylab = expression("|"*Delta*" Frameshifts per MB|"),
     ylab = "",
     xaxs = "i")
for (m1 in seq_len(nrow(fs_vals06))) {
  for (m2 in seq_len(ncol(fs_vals06) / 3L)) {
    c1 <- predictResponse(coef = fs_vals06[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = 0,
                          QUAL = qual_set,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertQuality(qual = qual_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}
L <- legend(x = 32,
            y = 3.7,
            legend = rep(NA, 18),
            col = rep(ColVec1[seq_len(6)],
                      3L),
            lty = c(rep(1, 6),
                    rep(2, 6),
                    rep(3, 6)),
            pch = rep(NA, 18),
            ncol = 3L,
            bty = 'n',
            x.intersp = 0.5,
            inset = 0.02,
            cex = 0.75)
legend(x = 32,
       y = 3.7,
       legend = c("MEGAHIT",
                  "SKESA",
                  "SPAdes",
                  "Unicycler",
                  "Unicycler + ONT",
                  "Unicycler + PB"),
       # col = rep(NA, 6),
       # lty = rep(NA, 6),
       ncol = 1,
       x.intersp = 7.5,
       bg = NA,
       bty = "n",
       cex = 0.75)
text(x = c(32, 33, 34),
     y = 3.725,
     pos = 4,
     xpd = TRUE,
     cex = 0.75,
     labels = rep(c("HiSeq 2500",
                    "HiSeq X",
                    "MiSeq v3"),
                  3L),
     srt = 45,
     adj = 0)
# single end internal stops for average q-score
par(mar = c(3, 2, 1.5, 1),
    mgp = c(2, 0.75, 0),
    cex.lab = 1,
    cex.axis = 1,
    cex.main = 1,
    cex.sub = 1)
plot(x = 0,
     y = 0,
     type = "n",
     xlim = c(30, 40),
     ylim = c(0, 5),
     xlab = "Average Q-score",
     yaxt = "n",
     # ylab = expression("|"*Delta*" Internal stops per MB|"),
     ylab = "",
     xaxs = "i")
for (m1 in seq_len(nrow(is_vals06))) {
  for (m2 in seq_len(ncol(is_vals06) / 3L)) {
    c1 <- predictResponse(coef = is_vals06[m1, c(m2, m2 + 3L, m2 + 6L)],
                          COV = 0,
                          QUAL = qual_set,
                          TOT_GENE = tot_genes,
                          TOT_NT = tot_nts)
    c2 <- convertQuality(qual = qual_set)
    lines(x = c2,
          y = c1,
          col = ColVec1[m1],
          lty = m2)
  }
}
```

# Figure S5: Modeled behavior of assemblies from simulated single end reads
Predicted models for the absolute difference in frameshifts (top) and internal stops (bottom) per Mbp from a source genome for assemblies generated from simulated single end reads as coverage varies against a fixed quality score of 34 for the short reads (left) and as quality score varies against a fixed coverage of 50-fold for the short reads (right).

\newpage

```{r, relative-event-correlations-1, include = TRUE, echo = FALSE}
load(file = "InputData/SimulatedEcoliANIResults.RData",
     verbose = FALSE)
load(file = "InputData/SimulatedEcoliStats_v3.RData",
     verbose = FALSE)

datx <- data.frame("ANI" = c(cor(x = dat5$ANI,
                                 y = abs(dat5$abs_fs - dat5$found_ref_fs) / dat5$total_genes,
                                 method = "spearman"),
                             cor(x = dat5$ANI,
                                 y = abs(dat5$abs_is - dat5$found_ref_is) / dat5$total_genes,
                                 method = "spearman"),
                             cor(x = dat5$ANI,
                                 y = dat5$total_contigs,
                                 method = "spearman"),
                             cor(x = dat5$ANI,
                                 y = dat5$fragment,
                                 method = "spearman"),
                             cor(x = dat5$ANI[!is.na(dat5$p_val)],
                                 y = dat5$p_val[!is.na(dat5$p_val)],
                                 method = "spearman"),
                             cor(x = dat5$ANI[!is.na(dat5$p_val)],
                                 y = dat5$D[!is.na(dat5$p_val)],
                                 method = "spearman"),
                             cor(x = dat5$ANI[!is.na(dat5$p_val)],
                                 y = dat5$mean[!is.na(dat5$p_val)],
                                 method = "spearman")),
                   "AF" = c(cor(x = dat5$AF,
                                y = abs(dat5$abs_fs - dat5$found_ref_fs) / dat5$total_genes,
                                 method = "spearman"),
                            cor(x = dat5$AF,
                                y = abs(dat5$abs_is - dat5$found_ref_is) / dat5$total_genes,
                                method = "spearman"),
                            cor(x = dat5$AF,
                                y = dat5$total_contigs,
                                method = "spearman"),
                            cor(x = dat5$AF,
                                y = dat5$fragment,
                                method = "spearman"),
                            cor(x = dat5$AF[!is.na(dat5$p_val)],
                                y = dat5$p_val[!is.na(dat5$p_val)],
                                method = "spearman"),
                            cor(x = dat5$AF[!is.na(dat5$p_val)],
                                y = dat5$D[!is.na(dat5$p_val)],
                                method = "spearman"),
                            cor(x = dat5$AF[!is.na(dat5$p_val)],
                                y = dat5$mean[!is.na(dat5$p_val)],
                                method = "spearman")),
                   row.names = c("Delta_Rel_FS",
                                 "Delta_Rel_IS",
                                 "Total_Contigs",
                                 "Norm_N50",
                                 "KS_P_Val",
                                 "KS_Stat",
                                 "Mean_Coding_Length"))

layout(mat = matrix(data = 1:6,
                    ncol = 2L))
par(mar = c(2,4,3,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = abs(dat5$abs_fs - dat5$found_ref_fs) / dat5$total_genes,
     pch = 16,
     ylab = expression("|"*Delta*" FS per Mbp|"),
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = abs(abs_fs - found_ref_fs) / total_genes ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
# summary(lm(Y~X))$coefficients[2L, "Pr(>|t|)"]
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[1] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[1] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 99.8,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[1] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 99.8,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(format(ph2, scientific = TRUE, digits = 3)))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -3,
      at = 99.8,
      cex = 0.5)
par(mar = c(3,4,2,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = dat5$total_contigs,
     pch = 16,
     ylab = "Total Contigs",
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = total_contigs ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[3] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[3] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 99.6,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[3] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 99.6,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(ph2))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -3,
      at = 99.6,
      cex = 0.5)
par(mar = c(4,4,1,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = dat5$p_val,
     pch = 16,
     ylab = "K-S p-value",
     xlab = "Average Nucleotide Identity (%)",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = p_val ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[5] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[5] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 99.6,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[5] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 99.6,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(ph2))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -3,
      at = 99.6,
      cex = 0.5)
par(mar = c(2,3.5,3,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = abs(dat5$abs_is - dat5$found_ref_is) / dat5$total_genes,
     pch = 16,
     ylab = expression("|"*Delta*" IS per Mbp|"),
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = abs(abs_is - found_ref_is) / total_genes ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[2] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[2] * 10e2) / 10e2))),
      side = 3,
      line = -2,
      at = 99.5,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[2] * 10e2) / 10e2)),
      side = 3,
      line = -3,
      at = 99.5,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(ph2))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -4,
      at = 99.5,
      cex = 0.5)
par(mar = c(3,3.5,2,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = dat5$fragment,
     pch = 16,
     ylab = "Normalized N50",
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = fragment ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[4] * 10e3) / 10e3))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[4] * 10e3) / 10e3))),
      side = 3,
      line = -1,
      at = 99.5,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[4] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 99.5,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(ph2))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -3,
      at = 99.5,
      cex = 0.5)
par(mar = c(4,3.5,1,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$ANI,
     y = dat5$D,
     pch = 16,
     ylab = "K-S D-statistic",
     xlab = "Average Nucleotide Identity (%)",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = D ~ ANI, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
# ph2 <- trunc(summary(ph1)$coefficients[2L, "Pr(>|t|)"] * 1e3) / 1e3
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$ANI[6] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$ANI[6] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 99.6,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$ANI[6] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 99.6,
      cex = 0.5)
mtext(# bquote(paste("p-value = ", .(ph2))),
      text = paste("p-value = ", format(ph2, scientific = TRUE, digits = 3)),
      side = 3,
      line = -3,
      at = 99.6,
      cex = 0.5)

```

# Figure S6: Average Nucleotide Identity (ANI) correlations with assembly measures
ANI is shown versus extractable statistics about the assemblies generated from simulated *E. coli* reads. ANI versus the absolute difference between the relative frameshifts per Mbp of the generated assembly and the reference assembly (top left). ANI versus the absolute difference between the relative internal stops per Mbp of the generated assembly and the reference assembly (top right). ANI versus the total number of contigs in the generated assembly (middle left). ANI versus the contig N50 normalized to total nucleotides in the generated assembly (middle right). ANI versus the Kolmogorov-Smirnov test p-value when testing the distribution of CDS lengths for the generated assembly against the distribution of CDS lengths for the source assembly (bottom left). ANI versus the Kolmogorov-Smirnov test D-statistic when testing the distribution of CDS lengths for the generated assembly against the distribution of CDS lengths for the source assembly (bottom right). Coefficient of determination, spearman's rho, and p-value of the fitted slope being significant are included in each panel.

```{r, plot-mappings-1-table, include = FALSE, echo = FALSE}
# dropped per erik's ask
# Table S1: GCF_001593565.1 Mapping Types
s1 <- nchar(featuretypes) > 0
featuretypes <- featuretypes[s1]
featurenames <- featurenames[s1]

kable(x = data.frame("feature" = featurenames,
                     "type" = featuretypes))

# **Table 1: Mapping feature types for GCF_001593565.1** Feature names and types where mapped sanger reads imply an error in the source genbank assembly.
```


```{r, plot mappings 2, include = FALSE, echo = FALSE}
# removed per erik's ask
# Figure S2: GCF_000350925.1 Mapping Alignments

featuretypes <- featurenames <- vector(mode = "character",
                                       length = length(res1[[2L]]))

for (m1 in seq_along(res2[[2L]])) {
  x1 <- AlignSeqs(myXStringSet = res2[[2L]][[m1]],
                  verbose = FALSE)
  x2 <- gregexpr(pattern = "[^ATCG]",
                 text = x1)
  # if the concensus is entirely expected nucleotides, the read maps perfectly
  # skip plotting
  if (x2[[1]][1] == -1) {
    next
  }
  w1 <- min(x2[[1]][1])
  w2 <- max(x2[[1]][1])
  
  if (GENECALLS2$Type[which(GENECALLS2$ID == names(x1)[1])] == "pseudogene") {
    # cat("\nPseudogene\n")
    featuretypes[m1] <- "Pseudogene"
    featurenames[m1] <- names(x1)[1]
  } else {
    # cat("\nRegular gene\n")
    featuretypes[m1] <- "Gene"
    featurenames[m1] <- names(x1)[1]
  }
  plot(ggmsa(x1,
             start = w1 - 19,
             end = w2 + 19,
             color = "Chemistry_NT",
             seq_name = TRUE))
}

# **Figure 2: Mapping Disagreements for GCF_000350925.1** Alignments of sanger reads that imply an error in the deposited assembly. All 9 reads map, one maps twice, of these mappings 1 implies an error in the deposited genbank genome, in this case the implied error is present in a regular gene.
```


```{r, plot mappings 2 table, include = FALSE, echo = FALSE}
# removed per erik's ask
# # Table S2: GCF_000350925.1 Mapping Types
s1 <- nchar(featuretypes) > 0
featuretypes <- featuretypes[s1]
featurenames <- featurenames[s1]

kable(x = data.frame("feature" = featurenames,
                     "type" = featuretypes))
# **Table 2: Mapping feature types for GCF_000350925.1** Feature names and types where mapped sanger reads imply an error in the source genbank assembly.
```


```{r, relative event correlations 2, include = FALSE, echo = FALSE}

layout(mat = matrix(data = 1:6,
                    ncol = 2L))
par(mar = c(2,4,3,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = abs(dat5$abs_fs - dat5$found_ref_fs) / dat5$total_genes,
     pch = 16,
     ylab = expression("|"*Delta*" FS per Mbp|"),
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = abs(abs_fs - found_ref_fs) / total_genes ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[1] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[1] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 0.825,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[1] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.825,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.825,
      cex = 0.5)
par(mar = c(3,4,2,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = dat5$total_contigs,
     pch = 16,
     ylab = "Total Contigs",
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = total_contigs ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[3] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[3] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 0.825,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[3] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.825,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.825,
      cex = 0.5)
par(mar = c(4,4,1,1.5),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = dat5$p_val,
     pch = 16,
     ylab = "K-S p-value",
     xlab = "Alignment Fraction",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = p_val ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[5] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[5] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 0.825,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[5] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.825,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.825,
      cex = 0.5)
par(mar = c(2,3.5,3,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = abs(dat5$abs_is - dat5$found_ref_is) / dat5$total_genes,
     pch = 16,
     ylab = expression("|"*Delta*" IS per Mbp|"),
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = abs(abs_is - found_ref_is) / total_genes ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[2] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[2] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 0.825,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[2] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.825,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.825,
      cex = 0.5)
par(mar = c(3,3.5,2,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = dat5$fragment,
     pch = 16,
     ylab = "Normalized N50",
     xlab = "",
     # xaxt = "n",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = fragment ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[4] * 10e3) / 10e3))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[4] * 10e3) / 10e3))),
      side = 3,
      line = -1,
      at = 0.825,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[4] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.825,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.825,
      cex = 0.5)
par(mar = c(4,3.5,1,2),
    mgp = c(2.25, 1, 0))
plot(x = dat5$AF,
     y = dat5$D,
     pch = 16,
     ylab = "K-S D-statistic",
     xlab = "Alignment Fraction",
     # yaxs = "i",
     col = "#11111133")
ph1 <- lm(formula = D ~ AF, data = dat5)
ph2 <- summary(ph1)$coefficients[2L, "Pr(>|t|)"]
abline(ph1)
mtext(# text = substitute(paste("R^2 = ", X), list("X" = (trunc(dat4$AF[6] * 10e2) / 10e2))),
      text = bquote(paste(" ",R^2 , "= ", .(trunc(dat4$AF[6] * 10e2) / 10e2))),
      side = 3,
      line = -1,
      at = 0.925,
      cex = 0.5)
mtext(text = bquote(rho == .(trunc(datx$AF[6] * 10e2) / 10e2)),
      side = 3,
      line = -2,
      at = 0.925,
      cex = 0.5)
mtext(bquote(paste("P-value = ", .(ph2))),
      side = 3,
      line = -3,
      at = 0.925,
      cex = 0.5)

# Figure S3: Alignment Fraction (AF) correlations to assembly measures
# AF is shown versus extractable statistics about the assemblies generated from simulated *E. coli* reads. AF versus the absolute difference between the relative frameshifts per Mbp of the generated assembly and the reference assembly (top left). AF versus the absolute difference between the relative internal stops per Mbp of the generated assembly and the reference assembly (top right). AF versus the total number of contigs (middle left). AF versus the contig N50 normalized to total nucleotides in the generated assembly (middle right). AF versus the Kolmogorov-Smirnov test p-value (bottom left). AF versus the Kolmogorov-Smirnov test D-statistic (bottom right).

```

\newpage

```{r, combined-distribution-tables, include = TRUE, echo = FALSE}

alltabs <- do.call(rbind,
                   newtabs)

adjustedtab <- data.frame("FS_p_value" = alltabs[, 1],
                          "IS_p_value" = alltabs[, 3],
                          "Counts" = alltabs[, 5],
                          "sub. choice" = c(row.names(newtabs[[1]]),
                                            c("ILLUMINA 1x + CLC",
                                              "ILLUMINA 1x + Abyss",
                                              "ILLUMINA >= 2x + CLC",
                                              "ILLUMINA 1x + Skesa",
                                              "ILLUMINA 1x + Unicycler"),
                                            c("ILLUMINA 1x + Unicycler",
                                              "ILLUMINA ONT + Unicycler",
                                              "ILLUMINA 1x + Shovill",
                                              "BGISEQ ILLUMINA + SPADES",
                                              "ILLUMINA PACBIO + CANU"),
                                            c("ILLUMINA 1x + CLC",
                                              "ILLUMINA 1x + MIRA",
                                              "ILLUMINA 1x + Abyss",
                                              "ILLUMINA ONT + Unicycler",
                                              "ILLUMINA 1x + Velvet")),
                          row.names = paste(rep(TAXNAMES,
                                                each = 5),
                                            2:6))

kable(adjustedtab)

```

# Table S1: Pseudogene distributions by submitter choices
The dominant submitter combination in all cases was SPAdes and a single set of Illumina reads. The five accompanying plotted minor distributions for each panel in **Fig. S2** were compared against the major distribution for that species with the Kolmogorov-Smirnov test, recording the p-value for both frameshifts (FS) and internal stops (IS), along with the distribution counts.

```{r, e-coli-distribution-table, include = FALSE, echo = FALSE}

kable(x = newtabs[[1]],
      format.args = list("scientific" = TRUE),
      digits = 3)

# Table S1: *E. coli* pseudogene distributions by submitter choices
# The dominant submitter combination in all cases was SPAdes and a single set of Illumina reads. The five accompanying plotted minor distributions from **Fig. S2** were compared against the major distribution with the KS test, recording the p-value and D-statistic for both frameshifts and internal stops, along with the distribution counts. The *E. coli* SPAdes + 1x Illumina combination was represented by 4559 unique biosamples. Rows represent minor distributions one through five in **Fig. S2 (top left)**
```




```{r, l-monocytogenes-table, include = FALSE, echo = FALSE}

kable(x = newtabs[[2]],
      format.args = list("scientific" = TRUE),
      digits = 3)

# Table S2: *L. monocytogenes* pseudogene distributions by submitter choices
# The dominant submitter combination in all cases was SPAdes and a single set of Illumina reads. The five accompanying plotted minor distributions from **Fig. S2** were compared against the major distribution with the KS test, recording the p-value and D-statistic for both frameshifts and internal stops, along with the distribution counts. The *L. monocytogenes* SPAdes + 1x Illumina combination was represented by 1035 unique biosamples. Rows represent minor distributions one through five in **Fig. S2 (bottom left)**
```


```{r, k-pneumoniae-table, include = FALSE, echo = FALSE}

z1 <- newtabs[[3]]
row.names(z1) <- c("ILLUMINA 1x + Unicycler",
                   "ILLUMINA ONT + Unicycler",
                   "ILLUMINA 1x + Shovill",
                   "BGISEQ ILLUMINA + SPADES",
                   "ILLUMINA PACBIO + CANU")

kable(x = z1,
      format.args = list("scientific" = TRUE),
      digits = 3)

# Table S3: *K. pneumoniae* pseudogene distributions by submitter choices
# The dominant submitter combination in all cases was SPAdes and a single set of Illumina reads. The five accompanying plotted minor distributions from **Fig. S2** were compared against the major distribution with the KS test, recording the p-value and D-statistic for both frameshifts and internal stops, along with the distribution counts. The *K. pneumoniae* SPAdes + 1x Illumina combination was represented by 1035 unique biosamples. Rows represent minor distributions one through five in **Fig. S2 (top right)**
```


```{r, s-aureus-table, include = FALSE, echo = FALSE}

z1 <- newtabs[[4]]
row.names(z1) <- c("ILLUMINA 1x + CLC",
                   "ILLUMINA 1x + MIRA",
                   "ILLUMINA 1x + Abyss",
                   "ILLUMINA ONT + Unicycler",
                   "ILLUMINA 1x + Velvet")

kable(x = z1,
      format.args = list("scientific" = TRUE),
      digits = 3)

# z2 <- kable(newtabs[[4]],
#       format.args = list("scientific" = TRUE),
#       digits = 3)
# column_spec(z2, column = 2:3, width = "5cm")

# Table S4: *S. aureus* pseudogene distributions by submitter choices
# The dominant submitter combination in all cases was SPAdes and a single set of Illumina reads. The five accompanying plotted minor distributions from **Fig. S2** were compared against the major distribution with the KS test, recording the p-value and D-statistic for both frameshifts and internal stops, along with the distribution counts. The *S. aureus* SPAdes + 1x Illumina combination was represented by 921 unique biosamples. Rows represent minor distributions one through five in **Fig. S2 (bottom right)**
```


```{r, relative event correlations 2 table, include = FALSE, echo = FALSE}
# load(file = "InputData/SimulatedEcoliANIResults.RData",
#      verbose = FALSE)
# load(file = "InputData/SimulatedEcoliStats_v3.RData",
#      verbose = FALSE)
# 
# tbl <- kable(x = data.frame("ANI" = dat4$ANI,
#                             "AF" = dat4$AF,
#                             row.names = c("|Relative FS per Mbp|",
#                                           "|Relative IS per Mbp|",
#                                           "Total Contigs",
#                                           "Norm. N50",
#                                           "K-S p-value",
#                                           "K-S D-statistic",
#                                           "Mean Coding Length")))
# row_spec(kable_input = tbl,
#          row = 2,
#          bold = TRUE)

# Table S1: Coefficients of determination for ANI and AF
# R^2^ values calculated for ANI and AF with collected measures for assemblies produced from simulated reads.
```



```{r session info, echo = FALSE}
# sessionInfo()
```

